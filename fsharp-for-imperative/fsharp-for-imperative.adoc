:description: FSharp for Imperative.
:keywords: f#, functional, imperative
:stylesheet: readthedocs.css
:source-highlighter: pygments

""Discipline is freedom""
-- J. Wilink, Extreme Ownership


== Console output

Writing to the console we can use `printfn`.

[source, fsharp]
----
printfn "%s" "hello"
----

Format specifiers are similar to the ones in `C`, except `%A` which renders any
type.

== Interactive

There is a `F#` interpreter you can use interactively.
You can start it from the command line like this:

```
dotnet fsi
```

Then type your expression and end it with a double semi-colon for the expression evaluation to kick in.
The double semi-colon is inherited from ML, the language `F#` is derived from.
For example:

```
dotnet fsi

Microsoft (R) `F#` Interactive version 11.4.2.0 for `F#` 5.0
Copyright (c) Microsoft Corporation. All Rights Reserved.

For help type #help;;

> let x = 1
- let y = 3;;
val x : int = 1
val y : int = 3

>
```

Note that when using the compiler you don't need the double semi-colon to end an expression.

== Whitespace and Identation

`F#` is whitespace and indentation sensitive. The guide to formatting is https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting[here].
In summary:

- Use spaces not tabs.
- 4 spaces is prefered.
- You can use https://github.com/fsprojects/fantomas/#fantomas[Fantomas] to format code.

== Immutability

Immutability is a core idiom in functional programming. If you stick with this
pattern you will reap benefits when facing concurrent problems. For example the
properties of REST, i.e. stateless and idempotent, naturally emerge if the
code you write is immutable.

.F#
[source, fsharp]
----
let x = 1
----

is similar to

.c++
[source, c++]
----
const int x = 1;
----

We say that `x` is bound to a value, and the construct is called a `let
binding`. We don't use the term `assigned`.

== Functions

We don't call functions.
We say we `apply a function`, or a `function is applied`.
_So how do I apply a function?_
You have to give it an argument.

[source, fsharp]
----
let saySomething something = printfn "I say %s" something
...
saySomething "hello"
----

We don't use parantheses to apply functions.
Instead we pass in the next argument.
_But wait, I've seen cases where parantheses are used to call functions. What's going on?_
Sometimes that's a tuple or the unit value.

=== Functions, unit values and side-effect.

There is a difference between binding a name to a value and a name to a function.

For example, in the following code, the value `1` is bound to `x`
[source, fsharp]
----
let x = 1
----

A value is only ever evaluated once.
This can be seen in the following example.

[source, fsharp]
----
> let tothemoon = printfn "to the moon";;
to the moon
val tothemoon : unit = ()

> tothemoon;;
val it : unit = ()

> tothemoon;;
val it : unit = ()

> tothemoon;;
val it : unit = ()

>
----

So what's going on? `F#` realises that the `printfn` returns `unit`, evalutes the expression, and binds the resultant value to the indentifier `tothemoon`.
Remember, `F#` is a functional language and thinks that a function given the same input should return output that's the same.
In this case, `tothemoon` takes no input arguments, therefore its value should never change.
If its value is never changing, there's no need to evaluate it more than once.
And this is the chain of logic `F#` is following, which is why we don't see multiple lines of "to the moon" in the console.
_So how can we change this, because I want the side-effect to happen?_
We pass an argument to the function.
It can be any other value or another function.
In this case we will pass the unit value to the function.
The unit value is a special value of type unit.
It simply acts as a space filler, a do nothing argument.

[source, fsharp]
----
> let tothemoon () = printfn "to the moon";;
val tothemoon : unit -> unit

> tothemoon ();;
to the moon
val it : unit = ()

> tothemoon ();;
to the moon
val it : unit = ()

> tothemoon ();;
to the moon
val it : unit = ()
----

_Ok, but that still doesn't make sense. The argument is always the same value, so shouldn't it only be evaluated once?_
I asked the https://stackoverflow.com/questions/69997578/whats-the-theoretical-loophole-that-allows-f-or-any-functional-language-to-a/69999798#69999798[question on StackOverflow].
Basically `F#` makes no distinction between pure and impure functions therefore the compiler cannot memoize the function, so it can't remember that the previous result of a call to that function with a specific argument.

=== Returning values

Everything is an expression so write the expression your function evaluates to.

[source, fsharp]
----
let add x y = x + y
...
add (mult 2 3) 2
----

Note the placement of parentheses.
They encompass the first expression.
You have to do this since whitespace delimits arguments, so if the argument itself is an expression, then you need to use parantheses to group it, and tell the compiler that the expression is a single argument.

== Recursion versus Iteration

We use recursion because iteration requires changing state, a mutable variable,
and that breaks immutability. _But what about the stack?_ Don't worry about it
for now. There are ways to get around it using `fold` and/or `tail recursion`.

.Recursive factorial in F#
[source, fsharp]
----
let rec fac x =
  match x with
  | 0 -> 1
  | _ -> x * fac (x - 1)
----

.Iterative factorial in C++
[source, c++]
----
int fac(int x)
{
  int result = x;
  for (int i = x-1; i > 1; --i)
  {
    result *= i;
  }
  return result;
}
----

=== Tail calls

Tail calls are a way to overcome the stackoverflow problem when using
recurison. When writing a recursive function try to make it tail recursive.
_What is tail recursion?_ It means the final function applied is the recursive
function itself or a return path. _How do we convert a recursive function into a
tail recursive function?_ We thread an accumulator parameter through the
function.

For example, in the following factorial function, the function `helper` uses an accumulator parameter and is tail recursive.

[source, fsharp]
----
let fac x =
  let rec helper x acc =
    match x with
    | 0 -> acc
    | _ -> helper (x - 1) (x * acc)
  helper x 1

fac 5
----

=== Fold

:TODO

== Types

`F#` loves types.
Working with types is easy in `F#` and you'll get the most out of
the language in terms of correctness if you use them liberally.
They will save you writing trivial unit tests, so you can focus on the unit tests that
matter.
You'll be surprised when your program runs correctly for the first time.

Personally, I think of programming in `F#` as programming in with shapes.
The shapes are the types you define, and the functions morph the shapes.
Along the way you fill in the shapes with untyped data, bringing type information to what was previously untyped, and safely transform the typed data with your functions.
`F#` has enough power to peel apart these shapes, via pattern matching, and recombine them easily.

=== Type Inference

You'll notice that the examples don't follow the pattern of defining a variable
by its type and then initialising it. This is because `F#` uses type inference to
figure out what the type of the value is. This can take some getting used to,
and the compiler errors can cause some frustration, but it comes with practice,
and it's easier than dealing with `C++` template errors.

=== Unit

Unit type is special. It's like `void` in `C++` but it's a proper type and has a literal symbol `()` that represents it.
If you want your expression to evaluate to nothing, then end it with `()`.
It's often used in contexts where imperative langauges are the norm, liek the .NET classes.

[source, fsharp]
----
let foo () =
  do something
  ()
----

=== Discriminated Unions

These are so simple yet so powerful.
They are like an `enum` in `C++` but they are types.

[source, fsharp]
----
type Fruit =
  | Apple
  | Orange
  | Pear
----

The fruit names, `Apple` `Orange` and `Pear`, are called `constructors`.
They are used to construct the type `Fruit`.

[source, fsharp]
----
let fruit = Apple
----

DU's go hand in hand with pattern matching and match expressions, so I'll show an example here:

[source, fsharp]
----
let fruitName fruit =
  match fruit with
  | Apple -> "apple"
  | Orange -> "orange"
  | Pear -> "pear"
----

A DU can be defined in terms of other types.

[source, fsharp]
----
type Fruit =
  | Apple of string
  | Orange of string
  | Pear of string
----

And can be created using the `constructor`:

[source, fsharp]
----
let a = Apple "apple"
----

=== Records

A record is like a struct in `C++`.
It can contain multiple distinct named types.

[source, fsharp]
----
type User =
    { FirstName : string
      LastName : string
      Email : string }
----

You can create a record simply by writing its inner names.

[source, fsharp]
----
let initUser first last email =
  {FirstName = first; LastName = last; Email = email}
----

If there is a name clash you can use the fully qualified name:

[source, fsharp]
----
let initUser first last email =
  {User.FirstName = first; User.LastName = last; User.Email = email}
----

Matching a record can be done like this:

[source, fsharp]
----
match user with
| {Firstname = "sashan"} -> printfn "alive"
| _ -> printfn "unknown"
----

The `_` means _I don't care_ about that value. It matches anything.

=== Tuples

A tuple can contain multiple unamed distinct types.

=== Option and Result

Use this type instead of sentinel value.

=== Structural equality

`F#` has structural equality.
All types can be compared for equality without writing a comparison object, as you might have to do in `C#`
Additionally, because there are no nulls in the language, one doesn't have to write code to check for that invariant.

=== Side-effects

Understand what a side-effect is.
It's not the same as a medical side-effect, which is bad and unintended. Intentionallity has nothing to do with it.
In computer science the term side-effect has a different meaning from colloquial usage.
Understand it from the perspective of the function.
If a function returns a value and changes the state of another entity in the process of calculating that value to return, then it has a side-effect.
For example the function could change a database. The change to the database is a side-effect.
It happens as a side-effect of applying that function.

== Assignment

Although we want to write code immutably, there will be times you will need assign values, especially when working with the .NET classes.
To create a mutable value (a variable) we use the `mutable` keyword and use `<-` for assignment.

[source, fsharp]
----
let mutable x = 1

x <- 2
----

